#!/system/bin/sh

# Set PATH for Magisk, KernelSU, and Termux
export PATH="/data/adb/magisk:/data/adb/ksu/bin:/data/adb/ap/bin:$PATH:/data/data/com.termux/files/usr/bin"

# Clear screen and change to script directory
clear
cd "${0%/*}" || exit 1

# Define ANSI color codes
normal='\033[0m'
green='\033[0;32m'
red='\033[91m'

# Script paths and configuration
scripts=$(realpath "$0")
scripts_dir=$(dirname "$scripts")
mark_id="16777216/16777216"
table_id="222"

# Source configuration file
if [ ! -f "${scripts_dir}/box.config" ]; then
  echo "${red}Error: box.config not found in ${scripts_dir}${normal}"
  exit 1
fi
source "${scripts_dir}/box.config"

# Logging function with timestamp and color support
log() {
  export TZ=Asia/Shanghai
  local now=$(date +"[%Y-%m-%d %H:%M:%S %Z]")
  local level=$1
  local message=$2
  local color
  case "$level" in
    Info) color="\033[1;32m" ;;
    Warn) color="\033[1;33m" ;;
    Error) color="\033[1;31m" ;;
    *) color="\033[1;30m" ;;
  esac
  [ -t 1 ] && echo -e "${color}${now} [${level}]: ${message}${normal}" || echo "${now} [${level}]: ${message}"
}

# Generate UID list from user-package pairs
find_packages_uid() {
  uid_list=()
  for user_package in "${user_packages_list[@]}"; do
    user=$(echo "$user_package" | awk -F ':' '{print $1}')
    package=$(echo "$user_package" | awk -F ':' '{print $2}')
    uid=$(awk -v pkg="$package" '$1==pkg {print $2}' /data/system/packages.list)
    [ -n "$uid" ] && uid_list+=($(expr "$user" \* 100000 + "$uid"))
  done
}

# Create TUN device link
create_tun_link() {
  mkdir -p /dev/net
  [ ! -L /dev/net/tun ] && ln -sf /dev/tun /dev/net/tun
}

# Check if TUN device is active
probe_tun_device() {
  ip link show "${tun_device}" >/dev/null 2>&1
}

# Configure forwarding rules for TUN mode
forward() {
  local action=$1
  iptables -w 100 "$action" FORWARD -p udp -o "${tun_device}" -j ACCEPT
  iptables -w 100 "$action" FORWARD -p udp -i "${tun_device}" -j ACCEPT
  ip6tables -w 100 "$action" FORWARD -p udp -o "${tun_device}" -j ACCEPT
  ip6tables -w 100 "$action" FORWARD -p udp -i "${tun_device}" -j ACCEPT
}

# Enable IPv6 support
enable_ipv6() {
  echo 1 > /proc/sys/net/ipv6/conf/all/accept_ra
  echo 1 > /proc/sys/net/ipv6/conf/wlan0/accept_ra
  echo 0 > /proc/sys/net/ipv6/conf/all/disable_ipv6
  echo 0 > /proc/sys/net/ipv6/conf/default/disable_ipv6
  echo 0 > /proc/sys/net/ipv6/conf/wlan0/disable_ipv6
}

# Disable IPv6 support
disable_ipv6() {
  echo 0 > /proc/sys/net/ipv6/conf/all/accept_ra
  echo 0 > /proc/sys/net/ipv6/conf/wlan0/accept_ra
  echo 1 > /proc/sys/net/ipv6/conf/all/disable_ipv6
  echo 1 > /proc/sys/net/ipv6/conf/default/disable_ipv6
  echo 1 > /proc/sys/net/ipv6/conf/wlan0/disable_ipv6
}

# Shared function to set up bypass rules for intranet subnets (IPv4 and IPv6)
setup_intranet_bypass() {
  local chain=$1 table=$2 iptables_cmd=$3
  if [ "$iptables_cmd" = "ip6tables -w 100" ]; then
    for subnet in "${intranet6[@]}"; do
      $iptables_cmd -t "$table" -A "$chain" -d "$subnet" -j RETURN
      if [ "$table" = "mangle" ]; then
        $iptables_cmd -t mangle -A "$chain" -d "$subnet" -p udp ! --dport 53 -j RETURN
        $iptables_cmd -t mangle -A "$chain" -d "$subnet" ! -p udp -j RETURN
      fi
    done
    $iptables_cmd -t "$table" -N LOCAL_IP_V6 2>/dev/null || $iptables_cmd -t "$table" -F LOCAL_IP_V6
    $iptables_cmd -t "$table" -A "$chain" -j LOCAL_IP_V6
  else
    for subnet in "${intranet[@]}"; do
      $iptables_cmd -t "$table" -A "$chain" -d "$subnet" -j RETURN
      if [ "$table" = "mangle" ]; then
        $iptables_cmd -t mangle -A "$chain" -d "$subnet" -p udp ! --dport 53 -j RETURN
        $iptables_cmd -t mangle -A "$chain" -d "$subnet" ! -p udp -j RETURN
      fi
    done
    $iptables_cmd -t "$table" -N LOCAL_IP_V4 2>/dev/null || $iptables_cmd -t "$table" -F LOCAL_IP_V4
    $iptables_cmd -t "$table" -A "$chain" -j LOCAL_IP_V4
  fi
}

# Enhanced proxy mode setup
start_enhance() {
  iptables="iptables -w 100"
  # Initialize NAT chains (IPv4)
  $iptables -t nat -N BOX_EXTERNAL 2>/dev/null || $iptables -t nat -F BOX_EXTERNAL
  $iptables -t nat -N BOX_LOCAL 2>/dev/null || $iptables -t nat -F BOX_LOCAL

  # Setup bypass for intranet subnets (IPv4)
  setup_intranet_bypass BOX_EXTERNAL nat "$iptables"
  setup_intranet_bypass BOX_LOCAL nat "$iptables"

  # Configure TCP redirection for specified interfaces
  if [ -n "${ap_list}" ]; then
    for ap in "${ap_list[@]}"; do
      $iptables -t nat -A BOX_EXTERNAL -p tcp -i "$ap" -j REDIRECT --to-ports "${redir_port}"
    done
    log Info "${ap_list[*]} TCP transparent proxy."
  fi

  # Insert NAT rules
  $iptables -t nat -I PREROUTING -j BOX_EXTERNAL
  $iptables -t nat -A BOX_LOCAL -m owner --gid-owner 23333 -j RETURN

  # Proxy mode: blacklist-like for TCP
  if [ ${#uid_list[@]} -eq 0 ]; then
    $iptables -t nat -A BOX_LOCAL -p tcp -j REDIRECT --to-ports "${redir_port}"
    log Info "TCP transparent proxy for all apps."
  else
    for appid in "${uid_list[@]}"; do
      $iptables -t nat -A BOX_LOCAL -m owner --uid-owner "$appid" -j RETURN
    done
    $iptables -t nat -A BOX_LOCAL -p tcp -j REDIRECT --to-ports "${redir_port}"
    log Info "TCP proxy mode: ${mode}, ${user_packages_list[*]} no transparent proxy."
  fi

  $iptables -t nat -I OUTPUT -j BOX_LOCAL
  $iptables -A OUTPUT -d 127.0.0.1 -p tcp -m owner --gid-owner 23333 --dport "${redir_port}" -j REJECT

  # Initialize mangle chains for UDP TPROXY (IPv4 and IPv6)
  for iptables in "iptables -w 100" "ip6tables -w 100"; do
    $iptables -t mangle -N BOX_EXTERNAL 2>/dev/null || $iptables -t mangle -F BOX_EXTERNAL
    $iptables -t mangle -N BOX_LOCAL 2>/dev/null || $iptables -t mangle -F BOX_LOCAL

    # Setup DNS redirection
    $iptables -t mangle -A BOX_EXTERNAL -p udp --dport 53 -j TPROXY --on-port "${tproxy_port}" --tproxy-mark "${mark_id}"
    $iptables -t mangle -A BOX_LOCAL -p udp --dport 53 -j TPROXY --on-port "${tproxy_port}" --tproxy-mark "${mark_id}"

    # Setup bypass for intranet subnets
    setup_intranet_bypass BOX_EXTERNAL mangle "$iptables"

    # Configure UDP TPROXY
    $iptables -t mangle -A BOX_EXTERNAL -p udp -m socket --transparent -j MARK --set-xmark "${mark_id}"
    $iptables -t mangle -A BOX_EXTERNAL -m socket -j RETURN
    $iptables -t mangle -A BOX_EXTERNAL -p udp -i lo -j TPROXY --on-port "${tproxy_port}" --tproxy-mark "${mark_id}"
    if [ -n "${ap_list}" ]; then
      for ap in "${ap_list[@]}"; do
        $iptables -t mangle -A BOX_EXTERNAL -p udp -i "$ap" -j TPROXY --on-port "${tproxy_port}" --tproxy-mark "${mark_id}"
      done
      log Info "${ap_list[*]} UDP transparent proxy ($iptables)."
    fi

    $iptables -t mangle -I PREROUTING -j BOX_EXTERNAL
    $iptables -t mangle -A BOX_LOCAL -m owner --gid-owner 23333 -j RETURN

    # Proxy mode: blacklist-like for UDP
    if [ ${#uid_list[@]} -eq 0 ]; then
      $iptables -t mangle -A BOX_LOCAL -p udp -j MARK --set-xmark "${mark_id}"
      log Info "UDP transparent proxy for all apps, including DNS ($iptables)."
    else
      for appid in "${uid_list[@]}"; do
        $iptables -t mangle -A BOX_LOCAL -m owner --uid-owner "$appid" -j RETURN
      done
      $iptables -t mangle -A BOX_LOCAL -p udp -j MARK --set-xmark "${mark_id}"
      log Info "UDP proxy mode: ${mode}, ${user_packages_list[*]} no transparent proxy, DNS via TPROXY ($iptables)."
    fi

    $iptables -t mangle -I OUTPUT -j BOX_LOCAL
    $iptables -t mangle -N DIVERT 2>/dev/null || $iptables -t mangle -F DIVERT
    $iptables -t mangle -A DIVERT -j MARK --set-xmark "${mark_id}"
    $iptables -t mangle -A DIVERT -j ACCEPT
    $iptables -t mangle -I PREROUTING -p tcp -m socket -j DIVERT
    if [ "$iptables" = "ip6tables -w 100" ]; then
      $iptables -A OUTPUT -d ::1 -p udp -m owner --gid-owner 23333 --dport "${tproxy_port}" -j REJECT
    else
      $iptables -A OUTPUT -d 127.0.0.1 -p udp -m owner --gid-owner 23333 --dport "${tproxy_port}" -j REJECT
    fi
  done
}

# Stop enhanced proxy mode
stop_enhance() {
  iptables="iptables -w 100"
  $iptables -t nat -D PREROUTING -j BOX_EXTERNAL 2>/dev/null
  $iptables -t nat -D OUTPUT -j BOX_LOCAL 2>/dev/null
  $iptables -t nat -F BOX_EXTERNAL 2>/dev/null
  $iptables -t nat -X BOX_EXTERNAL 2>/dev/null
  $iptables -t nat -F BOX_LOCAL 2>/dev/null
  $iptables -t nat -X BOX_LOCAL 2>/dev/null
  $iptables -t nat -F LOCAL_IP_V4 2>/dev/null
  $iptables -t nat -X LOCAL_IP_V4 2>/dev/null
  $iptables -D OUTPUT -d 127.0.0.1 -p tcp -m owner --gid-owner 23333 --dport "${redir_port}" -j REJECT 2>/dev/null

  for iptables in "iptables -w 100" "ip6tables -w 100"; do
    ip_cmd="ip"
    [ "$iptables" = "ip6tables -w 100" ] && ip_cmd="ip -6"
    $ip_cmd rule del fwmark "${mark_id}" table "${table_id}" 2>/dev/null
    $ip_cmd route flush table "${table_id}" 2>/dev/null
    $iptables -t mangle -D PREROUTING -j BOX_EXTERNAL 2>/dev/null
    $iptables -t mangle -D PREROUTING -p tcp -m socket -j DIVERT 2>/dev/null
    $iptables -t mangle -D OUTPUT -j BOX_LOCAL 2>/dev/null
    $iptables -t mangle -F BOX_EXTERNAL 2>/dev/null
    $iptables -t mangle -X BOX_EXTERNAL 2>/dev/null
    $iptables -t mangle -F BOX_LOCAL 2>/dev/null
    $iptables -t mangle -X BOX_LOCAL 2>/dev/null
    $iptables -t mangle -F DIVERT 2>/dev/null
    $iptables -t mangle -X DIVERT 2>/dev/null
    if [ "$iptables" = "ip6tables -w 100" ]; then
      $iptables -D OUTPUT -d ::1 -p udp -m owner --gid-owner 23333 --dport "${tproxy_port}" -j REJECT 2>/dev/null
    else
      $iptables -D OUTPUT -d 127.0.0.1 -p udp -m owner --gid-owner 23333 --dport "${tproxy_port}" -j REJECT 2>/dev/null
    fi
    $iptables -t mangle -F LOCAL_IP_V4 2>/dev/null
    $iptables -t mangle -X LOCAL_IP_V4 2>/dev/null
    $iptables -t mangle -F LOCAL_IP_V6 2>/dev/null
    $iptables -t mangle -X LOCAL_IP_V6 2>/dev/null
  done
}

# TPROXY mode setup
start_tproxy() {
  for iptables in "iptables -w 100" "ip6tables -w 100"; do
    ip_cmd="ip"
    [ "$iptables" = "ip6tables -w 100" ] && ip_cmd="ip -6"
    $ip_cmd rule add fwmark "${mark_id}" table "${table_id}" pref "${table_id}"
    $ip_cmd route add local default dev lo table "${table_id}"

    $iptables -t mangle -N BOX_EXTERNAL 2>/dev/null || $iptables -t mangle -F BOX_EXTERNAL
    $iptables -t mangle -N BOX_LOCAL 2>/dev/null || $iptables -t mangle -F BOX_LOCAL

    setup_intranet_bypass BOX_EXTERNAL mangle "$iptables"
    setup_intranet_bypass BOX_LOCAL mangle "$iptables"

    $iptables -t mangle -A BOX_EXTERNAL -p tcp -i lo -j TPROXY --on-port "${tproxy_port}" --tproxy-mark "${mark_id}"
    $iptables -t mangle -A BOX_EXTERNAL -p udp -i lo -j TPROXY --on-port "${tproxy_port}" --tproxy-mark "${mark_id}"

    if [ -n "${ap_list}" ]; then
      for ap in "${ap_list[@]}"; do
        $iptables -t mangle -A BOX_EXTERNAL -p tcp -i "$ap" -j TPROXY --on-port "${tproxy_port}" --tproxy-mark "${mark_id}"
        $iptables -t mangle -A BOX_EXTERNAL -p udp -i "$ap" -j TPROXY --on-port "${tproxy_port}" --tproxy-mark "${mark_id}"
      done
      log Info "${ap_list[*]} transparent proxy ($iptables)."
    fi

    $iptables -t mangle -I PREROUTING -j BOX_EXTERNAL
    $iptables -t mangle -A BOX_LOCAL -m owner --gid-owner 23333 -j RETURN

    if [ ${#uid_list[@]} -eq 0 ]; then
      $iptables -t mangle -A BOX_LOCAL -p tcp -j MARK --set-mark "${mark_id}"
      $iptables -t mangle -A BOX_LOCAL -p udp -j MARK --set-mark "${mark_id}"
      log Info "Transparent proxy for all apps ($iptables)."
    else
      for appid in "${uid_list[@]}"; do
        $iptables -t mangle -A BOX_LOCAL -m owner --uid-owner "$appid" -j RETURN
      done
      $iptables -t mangle -A BOX_LOCAL -p tcp -j MARK --set-mark "${mark_id}"
      $iptables -t mangle -A BOX_LOCAL -p udp -j MARK --set-mark "${mark_id}"
      log Info "Proxy mode: ${mode}, ${user_packages_list[*]} no transparent proxy ($iptables)."
    fi

    $iptables -t mangle -I OUTPUT -j BOX_LOCAL
    $iptables -t mangle -N DIVERT 2>/dev/null || $iptables -t mangle -F DIVERT
    $iptables -t mangle -A DIVERT -j MARK --set-mark "${mark_id}"
    $iptables -t mangle -A DIVERT -j ACCEPT
    $iptables -t mangle -I PREROUTING -p tcp -m socket -j DIVERT
    if [ "$iptables" = "ip6tables -w 100" ]; then
      $iptables -A OUTPUT -d ::1 -p tcp -m owner --gid-owner 23333 --dport "${tproxy_port}" -j REJECT
    else
      $iptables -A OUTPUT -d 127.0.0.1 -p tcp -m owner --gid-owner 23333 --dport "${tproxy_port}" -j REJECT
    fi
  done
}

# Stop TPROXY mode
stop_tproxy() {
  for iptables in "iptables -w 100" "ip6tables -w 100"; do
    ip_cmd="ip"
    [ "$iptables" = "ip6tables -w 100" ] && ip_cmd="ip -6"
    $ip_cmd rule del fwmark "${mark_id}" table "${table_id}" 2>/dev/null
    $ip_cmd route flush table "${table_id}" 2>/dev/null
    $iptables -t mangle -D PREROUTING -j BOX_EXTERNAL 2>/dev/null
    $iptables -t mangle -D PREROUTING -p tcp -m socket -j DIVERT 2>/dev/null
    $iptables -t mangle -D OUTPUT -j BOX_LOCAL 2>/dev/null
    $iptables -t mangle -F BOX_EXTERNAL 2>/dev/null
    $iptables -t mangle -X BOX_EXTERNAL 2>/dev/null
    $iptables -t mangle -F BOX_LOCAL 2>/dev/null
    $iptables -t mangle -X BOX_LOCAL 2>/dev/null
    $iptables -t mangle -F DIVERT 2>/dev/null
    $iptables -t mangle -X DIVERT 2>/dev/null
    if [ "$iptables" = "ip6tables -w 100" ]; then
      $iptables -D OUTPUT -d ::1 -p tcp -m owner --gid-owner 23333 --dport "${tproxy_port}" -j REJECT 2>/dev/null
    else
      $iptables -D OUTPUT -d 127.0.0.1 -p tcp -m owner --gid-owner 23333 --dport "${tproxy_port}" -j REJECT 2>/dev/null
    fi
    $iptables -t mangle -F LOCAL_IP_V4 2>/dev/null
    $iptables -t mangle -X LOCAL_IP_V4 2>/dev/null
    $iptables -t mangle -F LOCAL_IP_V6 2>/dev/null
    $iptables -t mangle -X LOCAL_IP_V6 2>/dev/null
  done
}

# Start TUN mode
start_tun() {
  create_tun_link
  if ! probe_tun_device; then
    log Error "TUN device ${tun_device} not found or inactive."
    return 1
  fi
  forward -I
}

# Stop TUN mode
stop_tun() {
  forward -D 2>/dev/null
}

# Start the proxy service
start() {
  if [ -z "${mode}" ] || [ -z "${binfile}" ] || [ -z "${workfile}" ]; then
    log Error "Missing required configuration: mode, binfile, or workfile."
    exit 1
  fi
  if [ ! -f "${binfile}" ]; then
    log Error "Binary file ${binfile} not found."
    exit 1
  fi
  chmod 755 "${binfile}"
  chown root:net_admin "${binfile}"
  ulimit -SHn 1048576
  [ "${ipv6}" = "enable" ] && enable_ipv6 && log Info "IPv6 enabled." || disable_ipv6
  case "${mode}" in
    tproxy)
      if ! zcat /proc/config.gz | grep -q TPROXY; then
        log Error "Kernel does not support TPROXY."
        exit 1
      fi
      start_tproxy
      ;;
    tun) start_tun ;;
    enhance) start_enhance ;;
    *) log Error "Invalid mode: ${mode}"; exit 1 ;;
  esac
  ${busybox:-busybox} setuidgid 0:23333 nohup "${binfile}" run -c "${workfile}" -D ../run/ >/dev/null 2>../run/error_sing-box.log &
  log Info "Started ${binfile} in ${mode} mode."
}

# Stop the proxy service
stop() {
  if pid=$(pidof "${binfile}"); then
    kill -15 "$pid" 2>/dev/null
    log Info "Stopped ${binfile} (PID: $pid)."
  fi
  case "${mode}" in
    tproxy) stop_tproxy ;;
    tun) stop_tun ;;
    enhance) stop_enhance ;;
    *) log Warn "No valid mode specified for cleanup." ;;
  esac
  rm -f "${scripts_dir}/uids.list"
  enable_ipv6
}

# Get local IP address
net_ip() {
  ip route get 1.1.1.1 | awk '/src/ {print $NF; exit}'
}

# Get network SSID or return "mobile"
net_id() {
  local wlan_interfaces
  wlan_interfaces=($(iw dev | awk '$1=="Interface" {print $2}'))
  for interface in "${wlan_interfaces[@]}"; do
    ssid=$(iw dev "$interface" link | awk '/SSID/ {print $2}')
    [ -n "$ssid" ] && echo "$ssid" && return
  done
  echo "mobile"
}

# Restart the proxy
run() {
  stop
  start
}

# Created on May 9, 2024
# Updated on August 4, 2025 to add enhance mode and fix DNS
# Optimized on August 6, 2025 for efficiency and robustness
# Updated on August 6, 2025 to add IPv6 support
